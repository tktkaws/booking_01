## Supabase 設定の意図と背景（フロントエンド向け）

対象: バックエンド設計に不慣れなフロントエンドエンジニア向けに、`docs/supabase_setup.md` の各設定を「なぜそうするのか」を中心に解説します。

---

## 全体方針

- 目的: 不正なデータを「入れさせない」設計（DB 主導の整合性）
- 手段: 制約（constraints）/ 排他（exclusion）/ RLS（Row Level Security）/ トリガー（trigger）/ 補助関数（helper functions）
- ねらい: クライアントのバグや悪意があっても、DB が一貫性と権限境界を守る

フロントのバリデーションは UX のために必要ですが、「最終防衛線」は DB で担保します。これにより、API の抜け道やツール直叩きでも壊れた状態が入りません。

---

## なぜ `timestamptz`（UTC）+ JST 変換？

- DB には `timestamptz`（タイムゾーン付き）で保存 → 世界共通の基準（UTC）で一意に扱える
- 業務ルール（平日 9:00–18:00、15 分刻み）は日本時間（JST）で判定 → `... at time zone 'Asia/Tokyo'` でチェック
- JST はサマータイムが無いので境界がシンプル（DST を気にしない）

結果として、「保存はグローバル基準・判定はローカル基準」という揺らぎの少ない設計になります。

---

## 15 分刻みと営業時間を DB 制約で縛る理由

- 画面や API でのチェック漏れがあっても、DB がはねてくれる
- バグ修正前に流入したデータも DB がブロック（再発防止）
- チェックは `check constraint`（宣言的）で実装 → 可読性が高く、パフォーマンスも安定

丸め（ラウンディング）はトリガーで任意に採用できます。丸めたくない場合は、UI 側で 15 分にスナップさせ、DB 側は「検証のみ」にして弾く方が分かりやすいこともあります。

---

## 予約の重複禁止を「半開区間」で判定する理由

- 区間を `[start, end)`（開始含む／終了含まず）に統一すると、ちょうど終わりとちょうど始まりが重ならない
- 例: 10:00–10:30 と 10:30–11:00 は非重複
- 実装は GiST 排他制約 + `tstzrange(start_at, end_at, '[)')`（`btree_gist` 拡張が必要）

これにより「同じ時間帯に同じ会議室が二重予約される」ことを DB レベルで防げます。

---

## `profiles` 設計と公開ビューの理由

- `profiles` には個人情報（`email`, `is_admin`）があるため、丸ごと公開したくない
- そこで、基表は本人/管理者だけ SELECT 可にし、匿名含む誰でも見られる公開ビュー `profiles_public` を用意
  - 公開ビューには非機微の列（`id, display_name, department`）だけを出す
  - UI は表示用に `profiles_public` を参照すれば安心

また部署は複数を許容するため `departments text[]` を採用し、先頭要素を「主部署」として `generated column department` で使いやすくしています。

---

## RLS（Row Level Security）を使う理由

- アプリ側の「誰が見られる・編集できる」ロジックを DB に寄せて、抜け漏れを無くす
- bookings の方針:
  - SELECT: 誰でも閲覧可（公開カレンダーの想定）
  - INSERT: 認証済のみ + 自部署のみ（`created_by` / `department` はサーバ側で自動付与、`with check` でも担保）
  - UPDATE/DELETE: 管理者 or 同部署
- `viewer_is_admin()` / `viewer_department()` ヘルパーで、SQL から自然に判定

RLS は「テーブルへの最終関門」。たとえ誤った API が作られても、RLS が不正操作を止めます。

---

## `created_by` と `department` をトリガーで自動付与する理由

- クライアントから信頼できない値（自分以外のユーザーIDや他部署）を送らせない
- DB がログイン中のユーザー（`auth.uid()`）から導出して安全に設定
- これにより、フロントは `title/description/start_at/end_at` だけ送ればよい（誤用しにくい）

さらに `updated_at` は更新トリガーで自動管理します。誰がどの列を更新してもタイムスタンプ整合が取れます。

---

## ルールは「宣言的に」書く（制約と RLS を優先）

- トリガーは便利ですが、可能な限り `check constraint` や `exclusion constraint`、`RLS policy` で宣言的に表現
- 宣言的なルールは読みやすく、パフォーマンスチューニングや移行（マイグレーション）も容易

---

## よくある落とし穴（ハマりポイント）

- RLS の式で `new.`/`old.` を使わない（トリガーと混同しない）。列名はそのまま書く
- `btree_gist` 拡張を忘れると排他制約が作れない
- タイムゾーン変換を忘れると「見かけ上 OK だが DB 判定 NG」になる（JST でチェック）
- 15 分刻みの丸めは UX と衝突することがある（丸める/弾くのいずれかをチームで統一）
- 公開ビューに機微情報を入れない（`email`, `is_admin` は非公開）

---

## カスタマイズの余地

- 重複禁止を部署単位にする: 排他制約に `department with =` を追加
- 公開範囲の調整: SELECT を匿名不可にする、部署内のみにするなど RLS で変更
- 祝日/社休日: `chk_business_hours` を関数化してカレンダーマスタと突き合わせる拡張
- 丸めポリシー: トリガーで丸める or DB では丸めず UI/サーバでスナップして「検証のみ」

---

## フロント実装への影響（最低限の持ち物）

- 作成/更新時に送るのは基本的に `title`, `description`, `start_at`, `end_at` のみ
- ユーザー/部署は DB 側で安全に補完される
- 表示用のユーザー名や部署名は `profiles_public` を JOIN または別取得で解決
- エラーハンドリングは DB の制約名で分岐すると実装が楽
  - 例: `chk_15min_start` なら「開始は 15 分刻みで入力してください」

---

## 小さなチートシート

- INSERT の RLS: `with check (...)` が「これから入る行がこの条件を満たすか」を検証
- UPDATE の RLS: `using (...)` で「今見えている行」を絞り、`with check (...)` で「更新後の行」も検証
- 半開区間: `[start, end)` で「端が揃う予約は重複しない」
- `auth.uid()`: Supabase の実行ユーザー ID。匿名だと `null`
- `stable` 関数: 同一クエリ内で結果が変わらない性質（RLS で使うヘルパーに適する）

---

## まとめ

- バリデーションと権限制御を DB に寄せることで、クライアントの実装ミスや将来の仕様変更にも強い
- 宣言的（制約/RLS）+ 最小限のトリガーで「壊れないデータモデル」を実現
- フロントは UI/UX とデータ表示に集中でき、バックエンドの安全性は DB に委ねられる

この方針により、予約アプリの信頼性・可用性・保守性が向上します。
